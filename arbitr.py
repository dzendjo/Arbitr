import requestsimport jsonimport csvimport sysfrom colorclass import Colorfrom terminaltables import AsciiTableclass Arbitr:    def __init__(self, csv_file_name):        self.csv_file_name = csv_file_name        self.URL_BITFINEX = 'https://api.bitfinex.com/v2/tickers?symbols='        self.URL_BITTREX = 'https://bittrex.com/api/v1.1/public/getmarketsummaries'        self.URL_KRAKEN = 'https://api.kraken.com/0/public/Ticker?pair='        self.URL_BINANCE = 'https://api.binance.com/api/v1/ticker/price'        self.URL_EXMO = 'https://api.exmo.com/v1/ticker/'        self.URL_HITBTC = 'https://api.hitbtc.com/api/2/public/ticker/'        self.URL_POLONIEX = 'https://poloniex.com/public?command=returnTicker'        self.names_of_market, self.universal_pairs = self.get_pair_list()    def dell_none_from_list(self, input_list):        return ','.join(item for item in input_list if item != 'None')    def dell_none(self, input_dict):        res_dict = {}        for key, value in input_dict.items():            if str(value) != 'None':                res_dict[key] = value        return res_dict    def get_all_pairs_by_market(self, market_name):        market_name_chaked = market_name.capitalize()        all_pairs_list = []        with open(self.csv_file_name) as csv_file:            dict_reader = csv.DictReader(csv_file, delimiter=";")            try:                for item in dict_reader:                    all_pairs_list.append(item[market_name_chaked])            except Exception:                return 'Ошибка в названии биржи: ' + str(sys.exc_info()[1])        return all_pairs_list    def get_pair_list(self):         with open(self.csv_file_name, newline='') as csvfile:            csvreader = csv.reader(csvfile)            names_of_markets = csvreader.__next__()[0].split(';')            universal_pairs = dict()            for row in csvreader:                row_list = row[0].split(';')                universal_pairs[row_list[0]] = row_list[1:]            return names_of_markets[1:], universal_pairs    def get_bitfinex_prices(self, pairs):        pair_dict = {}        try:            res = requests.request('GET', self.URL_BITFINEX + self.dell_none_from_list(pairs))        except Exception:            print('Нет соединения с Bitfinex: {}'.format(sys.exc_info()[1]), file=sys.stderr)            for key in self.universal_pairs.keys():                pair_dict[key] = 'None'            return pair_dict        try:            response_list = json.loads(res.text)            if not response_list:                for key in self.universal_pairs.keys():                    pair_dict[key] = 'None'                return pair_dict        except Exception:            print('Отдается не корректная страница на Bitfinex: {}'.format(sys.exc_info()[1]), file=sys.stderr)            for key in self.universal_pairs.keys():                pair_dict[key] = 'None'            return pair_dict        for i in range(len(pairs)):            if pairs[i] == 'None':                response_list.insert(i, 'None')        for pair, key in zip(response_list, self.universal_pairs.keys()):            try:                pair_dict[key] = float(pair[-4])            except Exception:                pair_dict[key] = 'None'        return pair_dict    def get_bittrex_prices(self, pairs):        pair_dict = {}        try:            res = requests.request('GET', self.URL_BITTREX)        except Exception:            print('Нет соединения с Bittrex: {}'.format(sys.exc_info()[1]), file=sys.stderr)            for key in self.universal_pairs.keys():                pair_dict[key] = 'None'            return pair_dict        try:            response_dict = json.loads(res.text)            if not response_dict:                for key in self.universal_pairs.keys():                    pair_dict[key] = 'None'                return pair_dict        except Exception:            print('Отдается не корректная страница на Bittrex: {}'.format(sys.exc_info()[1]), file=sys.stderr)            for key in self.universal_pairs.keys():                pair_dict[key] = 'None'            return pair_dict        for pair, key in zip(pairs, self.universal_pairs.keys()):            if pair == 'None':                pair_dict[key] = 'None'                continue            for item in response_dict['result']:                if item['MarketName'] == pair:                    pair_dict[key] = float(item['Last'])        return pair_dict    def get_binance_prices(self, pairs):        pair_dict = {}        try:            res = requests.request('GET', self.URL_BINANCE)        except Exception:            print('Нет соединения с Binance: {}'.format(sys.exc_info()[1]), file=sys.stderr)            for key in self.universal_pairs.keys():                pair_dict[key] = 'None'            return pair_dict        try:            response_dict = json.loads(res.text)            if not response_dict:                for key in self.universal_pairs.keys():                    pair_dict[key] = 'None'                return pair_dict        except Exception:            print('Отдается не корректная страница на Binance: {}'.format(sys.exc_info()[1]), file=sys.stderr)            for key in self.universal_pairs.keys():                pair_dict[key] = 'None'            return pair_dict        for pair, key in zip(pairs, self.universal_pairs.keys()):            if pair == 'None':                pair_dict[key] = 'None'                continue            for item in response_dict:                if item['symbol'] == pair:                    pair_dict[key] = float(item['price'])        return pair_dict    def get_kraken_prices(self, pairs):        pair_dict = {}        try:            res = requests.request('GET', self.URL_KRAKEN + self.dell_none_from_list(pairs))        except Exception:            print('Нет соединения с Kraken: {}'.format(sys.exc_info()[1]), file=sys.stderr)            for key in self.universal_pairs.keys():                pair_dict[key] = 'None'            return pair_dict        try:            response_dict = json.loads(res.text)            if not response_dict:                for key in self.universal_pairs.keys():                    pair_dict[key] = 'None'                return pair_dict        except Exception:            print('Отдается не корректная страница на Kraken: {}'.format(sys.exc_info()[1]), file=sys.stderr)            for key in self.universal_pairs.keys():                pair_dict[key] = 'None'            return pair_dict        for pair, key in zip(pairs, self.universal_pairs.keys()):            if pair == 'None':                pair_dict[key] = None                continue            try:                kraken_prefix = 'X' + pair[:3] + 'X' + pair[3:]                pair_dict[key] = float(response_dict['result'][kraken_prefix]['c'][0])            except Exception:                pair_dict[key] = None        return pair_dict    def get_exmo_prices(self, pairs):        pair_dict = {}        try:            res = requests.request('GET', self.URL_EXMO)        except Exception:            print('Нет соединения с Exmo: {}'.format(sys.exc_info()[1]), file=sys.stderr)            for key in self.universal_pairs.keys():                pair_dict[key] = 'None'            return pair_dict        try:            response_dict = json.loads(res.text)            if not response_dict:                for key in self.universal_pairs.keys():                    pair_dict[key] = 'None'                return pair_dict        except Exception:            print('Отдается не корректная страница на Exmo: {}'.format(sys.exc_info()[1]), file=sys.stderr)            for key in self.universal_pairs.keys():                pair_dict[key] = 'None'            return pair_dict        for pair, key in zip(pairs, self.universal_pairs.keys()):            if pair == 'None':                pair_dict[key] = 'None'                continue            try:                pair_dict[key] = float(response_dict[pair]['last_trade'])            except Exception:                pair_dict[key] = 'None'        return pair_dict    def get_hitbtc_prices(self, pairs):        pair_dict = {}        try:            res = requests.request('GET', self.URL_HITBTC)        except Exception:            print('Нет соединения с HitBTC: {}'.format(sys.exc_info()[1]), file=sys.stderr)            for key in self.universal_pairs.keys():                pair_dict[key] = 'None'            return pair_dict        try:            response_dict = json.loads(res.text)            if not response_dict:                for key in self.universal_pairs.keys():                    pair_dict[key] = 'None'                return pair_dict        except Exception:            print('Отдается не корректная страница на HitBTC: {}'.format(sys.exc_info()[1]), file=sys.stderr)            for key in self.universal_pairs.keys():                pair_dict[key] = 'None'            return pair_dict        for pair, key in zip(pairs, self.universal_pairs.keys()):            if pair == 'None':                pair_dict[key] = 'None'                continue            for item in response_dict:                try:                    if item['symbol'] == pair:                        pair_dict[key] = float(item['last'])                except Exception:                    pair_dict[key] = 'None'        return pair_dict    def get_poloniex_prices(self, pairs):        pair_dict = {}        try:            res = requests.request('GET', self.URL_POLONIEX)        except Exception:            print('Нет соединения с Poloniex: {}'.format(sys.exc_info()[1]), file=sys.stderr)            for key in self.universal_pairs.keys():                pair_dict[key] = 'None'            return pair_dict        try:            response_dict = json.loads(res.text)            if not response_dict:                for key in self.universal_pairs.keys():                    pair_dict[key] = 'None'                return pair_dict        except Exception:            print('Отдается не корректная страница на Poloniex: {}. \nПросто включите ВПН или что-то такое...!'.format(sys.exc_info()[1]), file=sys.stderr)            for key in self.universal_pairs.keys():                pair_dict[key] = 'None'            return pair_dict        for pair, key in zip(pairs, self.universal_pairs.keys()):            if pair == 'None':                pair_dict[key] = 'None'                continue            try:                pair_dict[key] = float(response_dict[pair]['last'])            except Exception:                pair_dict[key] = 'None'        return pair_dict    def get_all_pairs_prices(self):        pairs_prices_dict = {}        bitfinex_prices = self.get_bitfinex_prices(self.get_all_pairs_by_market('Bitfinex'))        bittrex_prices = self.get_bittrex_prices(self.get_all_pairs_by_market('Bittrex'))        binance_prices = self.get_binance_prices(self.get_all_pairs_by_market('Binance'))        kraken_prices = self.get_kraken_prices(self.get_all_pairs_by_market('Kraken'))        exmo_prices = self.get_exmo_prices(self.get_all_pairs_by_market('Exmo'))        hitbtc_prices = self.get_hitbtc_prices(self.get_all_pairs_by_market('Hitbtc'))        poloniex_prices = self.get_poloniex_prices(self.get_all_pairs_by_market('Poloniex'))        for pair in self.universal_pairs.keys():            pairs_prices_dict[pair] = {                'Bitfinex': bitfinex_prices[pair],                'Bittrex': bittrex_prices[pair],                'Kraken': kraken_prices[pair],                'Binance': binance_prices[pair],                'Exmo': exmo_prices[pair],                'Hitbtc': hitbtc_prices[pair],                'Poloniex': poloniex_prices[pair]            }        return pairs_prices_dict    def get_min_dict(self, price_dict):        minv = 10000000        for key, value in price_dict.items():            try:                float_value = float(value)            except Exception:                continue            if float_value < minv:                minv = float_value                name_of_min_market = key        return (minv, name_of_min_market)    def get_max_dict(self, price_dict):        maxv = 0        for key, value in price_dict.items():            try:                float_value = float(value)            except Exception:                continue            if float_value > maxv:                maxv = float_value                name_of_max_market = key        return (maxv, name_of_max_market)    # deprecated    def print_all_defferences(self):        pairs_prices_dict = self.get_all_pairs_prices()        res_s = ''        for pair in pairs_prices_dict:            res_s += str(pair) + ': ' + str(pairs_prices_dict[pair]) + '    '            min_list = self.get_min_in_list(pairs_prices_dict[pair])            max_list = self.get_max_in_list(pairs_prices_dict[pair])            difference = round((max_list[0] - min_list[0]) * 100 / min_list[0], 2)            res_s += str(difference) + '%  ' + min_list[1] + ' --> ' + max_list[1] + '\n'        print(res_s)    def print_nice_variants(self):        pairs_prices_dict = self.get_all_pairs_prices()        for pair_name, pairs_prices_dict in pairs_prices_dict.items():            block1 = ''            block2 = ''            pair_prices_dict_second_max = pairs_prices_dict.copy()            max_in_dict = self.get_max_dict(pairs_prices_dict)            # Тут удаляем 3 минимальных значения            for i in range(len(self.dell_none(pairs_prices_dict)) - 1):                min_in_dict = self.get_min_dict(pairs_prices_dict)                difference = round((max_in_dict[0] - min_in_dict[0]) * 100 / min_in_dict[0], 2)                if difference >= 1.5 and difference <= 2.5:                    block1 += Color('{autogreen}' + '{} --> {}: {}%'.format(min_in_dict[1], max_in_dict[1], difference)                                    + '{/autogreen}\n')                elif difference > 2:                    block1 += Color('{autoyellow}' + '{} --> {}: {}%'.format(min_in_dict[1], max_in_dict[1], difference)                                    + '{/autoyellow}\n')                else:                    block1 += '{} --> {}: {}%\n'.format(min_in_dict[1], max_in_dict[1], difference)                pairs_prices_dict.pop(min_in_dict[1])            # Тут удаляем масимальное значение            pair_prices_dict_second_max.pop(max_in_dict[1])            max_in_dict = self.get_max_dict(pair_prices_dict_second_max)            for i in range(len(self.dell_none(pair_prices_dict_second_max)) - 1):                min_in_dict = self.get_min_dict(pair_prices_dict_second_max)                difference = round((max_in_dict[0] - min_in_dict[0]) * 100 / min_in_dict[0], 2)                if difference >= 1.5 and difference <= 2:                    block2 += Color('{autogreen}' + '{} --> {}: {}%'.format(min_in_dict[1], max_in_dict[1], difference)                                    + '{/autogreen}\n')                elif difference > 2:                    block2 += Color('{autoyellow}' + '{} --> {}: {}%'.format(min_in_dict[1], max_in_dict[1], difference)                                    + '{/autoyellow}\n')                else:                    block2 += '{} --> {}: {}%\n'.format(min_in_dict[1], max_in_dict[1], difference)                pair_prices_dict_second_max.pop(min_in_dict[1])            table_data = [                    [block1, block2]]            table_instance = AsciiTable(table_data, Color('{autored}' + pair_name + '{/autored}'))            table_instance.inner_heading_row_border = False            print(table_instance.table)            print()